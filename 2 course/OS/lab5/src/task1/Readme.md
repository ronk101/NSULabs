# Создание, завершение процесса
## 1. Жизненный цикл процесса. ##
> a. Напишите программу, которая:
>> i. создает и инициализирует переменную (можно две: локальную и глобальную);\
>> ii. выводит ее (их) адрес(а) и содержимое;\
>> iii. выводит pid;\
>> iv. порождает новый процесс (используйте fork(2)).\
>> v. в дочернем процессе выводит pid и parent pid.\
>> vi. в дочернем процессе выводит адреса и содержимое переменных, созданных в пункте а;\
>> vii. в дочернем процессе изменяет содержимое переменных и выводит их значение;\
>> viii. в родительском процессе выводит содержимое переменных;\
>> ix. в родительском процессе делает sleep(30);\
>> x. в дочернем процессе завершается с кодом “5” (exit(2)).\
>> xi. в родительском процессе дожидается завершения дочернего,
вычитывает код завершения и выводит причину завершения и код
завершения если он есть. В каком случае кода завершения не
будет?
>
> b. Объясните результаты работы программы.\
> c. Понаблюдайте за адресными пространствами в `procfs`.\
> d. Понаблюдайте за состояниями процесса в `procfs` или с помощью утилиты `ps`.


# FAQ

Функция fork() является одним из основных механизмов создания новых процессов в операционных системах UNIX и UNIX-подобных системах. Она используется для создания дочернего процесса, который является практически идентичной копией родительского процесса. Вот как работает функция fork():

* При вызове fork(), операционная система создает новый процесс путем клонирования (дублирования) родительского процесса. В результате, в системе существуют два процесса - родительский и дочерний.
  
* Дочерний процесс является точной копией родительского процесса на момент вызова fork(). Он получает копию всей виртуальной памяти родительского процесса, включая код, данные, стек и открытые файловые дескрипторы. Однако, физическая память и файлы не копируются, а используются в режиме "копирования при записи" (copy-on-write).

* После создания дочернего процесса, fork() возвращает разные значения в родительском и дочернем процессах. В родительском процессе возвращается PID (идентификатор) дочернего процесса, а в дочернем процессе возвращается 0. Это позволяет родительскому и дочернему процессам определить, в каком из них они находятся.

* Родительский и дочерний процессы продолжают выполняться независимо друг от друга. Они имеют разные идентификаторы процессов (PID), их ресурсы, такие как файловые дескрипторы и открытые файлы, являются независимыми. Изменения, внесенные в одном процессе, не влияют на другой.

* При завершении дочернего процесса, он может передать код завершения родительскому процессу. Родительский процесс может получить код завершения дочернего процесса, вызвав функцию wait() или waitpid(). Это позволяет родительскому процессу получить информацию о завершении дочернего процесса и выполнить соответствующие действия.


Если родительский процесс завершается, не вызывая функцию `wait` или не обрабатывая сигналы завершения дочернего процесса, то дочерний процесс может остаться в состоянии зомби (zombie). Зомби-процесс продолжает занимать запись в таблице процессов, но не выполняет никаких действий.

Когда родительский процесс завершается, ядро операционной системы обычно принимает роль родителя для зомби-процесса и выполняет очистку его записи в таблице процессов. Очистка происходит автоматически, и зомби-процесс полностью удаляется из системы. Операционная система обрабатывает эту ситуацию, чтобы предотвратить накопление зомби-процессов и избежать исчерпания ресурсов системы.

Когда родительский процесс завершается, дочерний процесс становится зомби. Он продолжает занимать место в таблице процессов и хранит свой код завершения, но больше не выполняет никаких действий. Дочерний процесс остается в состоянии зомби до тех пор, пока родительский процесс не прочитает его код завершения с помощью `wait()`. После этого запись о дочернем процессе удаляется из таблицы процессов, и он полностью удаляется из системы.

Если в дочернем процессе возникнет ошибка сегментации `(Segmentation Fault)`, процесс будет завершен неперехватываемым сигналом `SIGSEGV`. В этом случае, код завершения дочернего процесса не будет доступен родительскому процессу, и информация о сигнале будет доступна через `WTERMSIG(status)`.

Код завершения дочернего процесса не будет доступен родительскому процессу в следующих случаях:

* Если дочерний процесс не завершился. Это может произойти, если дочерний процесс находится в бесконечном цикле или выполняет задачу, которая не завершается. В этом случае, родительский процесс может ожидать завершения дочернего с помощью функции `wait`, но вызов функции будет блокироваться до тех пор, пока дочерний процесс не завершится.

* Если дочерний процесс был остановлен сигналом, который не был перехвачен и не вызвал завершение процесса. Например, если дочерний процесс получил сигнал `SIGSTOP` или `SIGTSTP`, он будет приостановлен, и его код завершения не будет доступен родительскому процессу.