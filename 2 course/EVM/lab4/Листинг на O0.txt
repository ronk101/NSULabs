Exp:
        push    {r4, r5, r7, r8, r9, lr} пушим значения этих регистров, т.к. мы не можем поменять их значения в этой функции (нужно сохранить крч)
        vpush.64        {d8} пушит в стек регистр из VFP - расширения
        sub     sp, sp, #40		формируем фрейм под локальные переменные
        add     r7, sp, #0		запоминаем состояние стэк поинтера
        str     r0, [r7, #4]	// Сохраняем значение x (из аргумента) по адресу R7 со смещением 4, т.е. в стек
        ldr     r3, [r7, #4]	загружаем в регистр r3 переменную x
        vmov    s15, r3 @ int		копируем значение из регистра r3 в регистр расширений FVP s15
        vcvt.f64.s32    d16, s15 сохраняет из регистра s в регистр d (будет символ Integer S0 в качестве двойной точности и сохранить до D0)
        vstr.64 d16, [r7, #32]		сохранить регистр d16 в r7+32
        mov     r2, #0	кладём 0 в r2
        mov     r3, #0
        movt    r3, 16368 Записывает 16-битное немедленное значение в верхнюю половину слова регистра, не затрагивая нижнюю половину слова.
        strd    r2, [r7, #24]	записывает в стек r2 как дабл по адресу r7+24
        adr     r3, .L5		добавляет значение из .L5 в PC для формирования pc-относительного адреса и записывает его в дабл
        ldrd    r2, [r3]	загрузили в r2 значение находящиеся по адресу r3
        strd    r2, [r7, #8] записали в стек r2 как double
        mov     r2, #1	присвоили r2 единичку
        mov     r3, #0
        strd    r2, [r7, #16]	записали в стек r2 как дабл
        b       .L2
.L3:
        vldr.64 d17, [r7, #24]		псевдо-инструкция которая загружает в d17 значение из r7+24 с последующим увелечением
        vldr.64 d16, [r7, #32]		
        vadd.f64        d16, d17, d16	d16 = d17 + d16
        vstr.64 d16, [r7, #24]		положили в стек значение из регистра d16 с послед. уменьшением
        ldr     r3, [r7, #4]	положили в r3 значение из r7+4
        vmov    s15, r3 @ int	положили r3 в s15
        vcvt.f64.s32    d17, s15	преобразование из регистра в 64битный регистр
        vldr.64 d16, [r7, #32]		
        vmul.f64        d8, d17, d16	d8 = d17 * d16
        ldrd    r2, [r7, #16] в r2 знач из *r7+16
        adds    r8, r2, #1	сложили и установили флаги
        adc     r9, r3, #0	сложение с переносом
        mov     r0, r8		r0 = r8
        mov     r1, r9 \	r1 = r9
        bl      __aeabi_l2d		функция из стандартной библиотеки компилятора, преобразующая 32-разрядный int в 64-разрядный double
        vmov    d17, r0, r1 копировать два числа по 32 бита в одно 64 битное (r0-нижнии биты, r1 - верхние)
        vdiv.f64        d16, d8, d17	делит значения с плавающей запятой
        vstr.64 d16, [r7, #32]		загружаем в стек d16 с послед. уменьшением
        ldrd    r2, [r7, #16]	выгрузили из стека дабл
        adds    r4, r2, #1	прибавили единичку
        adc     r5, r3, #0	сложение с переносом
        strd    r4, [r7, #16]	загрузили в стек дабл
.L2:
        ldrd    r2, [r7, #16]	из стека в r2
        ldrd    r0, [r7, #8]	из стека в r0
        cmp     r0, r2	сравнили, получили флаги
        sbcs    r3, r1, r3	вычитание с переносом
        bge     .L3	условный переход больше или равно
        ldrd    r2, [r7, #24]	из стека в r2
        vmov    d16, r2, r3	d16 = lowerbitts(r2)+upperbits(r3)
        vmov.f64        d0, d16 d0 = d16
        adds    r7, r7, #40	r7 = r7 + 40
        mov     sp, r7	sp = r7
		! указывает , что обновленный базовый адрес должен быть записан обратно .
        vldm    sp!, {d8}	вытащили из стека d8 (в начале функции зачем-то пушили)
        pop     {r4, r5, r7, r8, r9, pc}	забираем значения регистров обратно
.L5:
        .word   400000000
        .word   0
.LC0:
        .ascii  "%lf\012\000"
main:
        push    {r7, lr} пушим r7 и link register (регистр адреса возврата из процедуры), т.к. нам нужно сохранить их значения(соглашения)
        sub     sp, sp, #8 sp = sp - 8
        add     r7, sp, #0 r7 = sp + 0
        movs    r0, #7		r0 = 7 Устанавливает флаги согласно результату выполнения инструкции
        bl      Exp		безусловный переход к функции
        vstr.64 d0, [r7]	*r7 = d0 с последующим уменьшением
        ldrd    r2, [r7]	r2 = *r7
        movw    r0, #:lower16:.LC0	нижние 16 бит	
        movt    r0, #:upper16:.LC0	верхние 16 бит
        bl      printf
		Возвращаем R7 и стек в исходное состояние
        movs    r3, #0
        mov     r0, r3
        adds    r7, r7, #8
        mov     sp, r7
        pop     {r7, pc}