Первый регистр - приёмник, зачастую не учавствует в вычислениях
Второй регистр - источник

Суффикс s (example movS) вляет на флаги, т.е. устанавливает какие-то флаги
b - безусловный переход

bl - вызов подпрограммы
bx - выход

Регистры. Программисту доступны 16 32-битных регистров общего
назначения (r0 – r15) и 32-битный регистр состояния (CPSR).

Регистр состояния (CPSR – current program status register) хранит
однобитовые флаги:
 знаковый флаг (N – Negative),
 флаг нуля (Z – Zero),
 флаг переноса (C – Carry),
 флаг переполнения (V – oVerflow),
а также другие поля, отражающие состояние процессора.
Флаги записываются в r15

rsb - обратное вычитание, например rsb r7, r5, #100 - из 100 вычитаем r5 и записываем в r7

команды обращения в память выделены в отделеньные команды load и store (ld, st)

ldrd    r2, [r7, #16] - по адрессу r7+16 байт читается какое-то число, r6 остаётся каким был

push -пушит в стэк по адресу stack pointer набор регистров {}
pop вычитает из памяти набор регистров {}
 stmdb	sp!, {r4, r5, r7, r8, r9, lr} !-значит что sp не включается в это множество
 vpush {s0-s5} /* Equivalent to vstmdb sp!, {s0-s5} */
вызов подпрограмм:
осуществляется командой bl на какую-то страшную функцию __*****__ (аналог call ASM) в отличие от x86 адрес пишется не в стэк, а в линк адрежсн (lr))
арм лучше x86, т.к. ей необязательно работать с стеком вообще
есть соглашения, которые говорят какие регистры могут поменяться в подпрограмме, а какие нет

Инструкция BL копирует адрес следующей инструкции в r14 (lr, регистр связи) и вызывает метку ветви.

S(0-31) -регистры 32 бита
D(0-15) - регистры 64 бита
Q(0-15) - 128 бит